{"ast":null,"code":"var _jsxFileName = \"/Users/rzeinalov/Developer/shell-game/client/src/ShellGameCanvas.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState } from 'react';\n\n/**\n * Props:\n *  - ballPosition: which cup (0..2) actually hides the ball\n *  - disabledCups: array of bools [cup0Disabled, cup1Disabled, cup2Disabled]\n *  - gameOver: bool\n *  - foundBall: bool (true if user guessed it)\n *  - onCupClick(index) => void\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction ShellGameCanvas({\n  ballPosition,\n  disabledCups,\n  gameOver,\n  foundBall,\n  onCupClick\n}) {\n  _s();\n  const canvasRef = useRef(null);\n  const width = 600;\n  const height = 300;\n\n  // We'll track each cup's color and current/target X positions for animation.\n  // They all share the same Y = 180\n  // Cup #0 => orange, #1 => red, #2 => gold\n  const [cups, setCups] = useState([{\n    curX: 100,\n    targetX: 100,\n    color: 'orange'\n  }, {\n    curX: 300,\n    targetX: 300,\n    color: 'red'\n  }, {\n    curX: 500,\n    targetX: 500,\n    color: 'gold'\n  }]);\n\n  // How many times we shuffle (swap) at the start\n  const shuffleTotal = 3;\n  // Track how many shuffle steps are left\n  const [shuffleStepsLeft, setShuffleStepsLeft] = useState(shuffleTotal);\n  // Are we currently shuffling?\n  const [shuffling, setShuffling] = useState(true);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n\n    // Load a background image if desired\n    const bgImage = new Image();\n    bgImage.src = '/background.jpg';\n    let animationFrameId;\n    function animate() {\n      updatePositions();\n      drawScene(ctx, bgImage);\n      animationFrameId = requestAnimationFrame(animate);\n    }\n    animate();\n\n    // Start the initial shuffle\n    doShuffle();\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n    };\n    // eslint-disable-next-line\n  }, []);\n\n  /**\n   * doShuffle():\n   * Called once to do a random shuffle. If we have multiple steps, once the cups\n   * arrive at their new positions, we call doShuffle() again, until shuffleStepsLeft=0.\n   * \n   * We ensure the new arrangement differs from the old arrangement so that cups actually move.\n   */\n  function doShuffle() {\n    if (shuffleStepsLeft <= 0) {\n      setShuffling(false);\n      return;\n    }\n\n    // Current arrangement\n    const oldPositions = cups.map(c => c.targetX);\n\n    // Generate a random permutation of the X positions [100, 300, 500]\n    let positions;\n    let isSame;\n    let attemptCount = 0;\n    do {\n      positions = [100, 300, 500];\n      for (let i = positions.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [positions[i], positions[j]] = [positions[j], positions[i]];\n      }\n      // Compare with old arrangement\n      isSame = positions.every((p, idx) => p === oldPositions[idx]);\n      attemptCount++;\n    } while (isSame && attemptCount < 10);\n\n    // Update each cup's targetX with the new (guaranteed different) permutation\n    setCups(prev => prev.map((cup, i) => ({\n      ...cup,\n      targetX: positions[i]\n    })));\n  }\n\n  // Move each cup from curX toward targetX each frame\n  function updatePositions() {\n    setCups(prevCups => {\n      let allArrived = true;\n      const newCups = prevCups.map(cup => {\n        const speed = 0.1; // fraction of distance to move each frame\n        const dx = cup.targetX - cup.curX;\n        if (Math.abs(dx) < 0.5) {\n          // Snap\n          return {\n            ...cup,\n            curX: cup.targetX\n          };\n        } else {\n          allArrived = false;\n          return {\n            ...cup,\n            curX: cup.curX + dx * speed\n          };\n        }\n      });\n\n      // If all cups arrived at their target, do next shuffle step\n      if (allArrived && shuffling && shuffleStepsLeft > 0) {\n        setShuffleStepsLeft(s => s - 1);\n        // Wait a moment, then do the next shuffle\n        setTimeout(() => {\n          doShuffle();\n        }, 300);\n      }\n      return newCups;\n    });\n  }\n  function drawScene(ctx, bgImage) {\n    ctx.clearRect(0, 0, width, height);\n\n    // Background\n    if (bgImage.complete && bgImage.naturalWidth > 0) {\n      ctx.drawImage(bgImage, 0, 0, width, height);\n    } else {\n      ctx.fillStyle = '#a5d8ff';\n      ctx.fillRect(0, 0, width, height);\n    }\n\n    // Draw cups\n    cups.forEach((cup, i) => {\n      const isDisabled = disabledCups[i];\n      drawCup3D(ctx, cup.curX, 180, cup.color, isDisabled);\n    });\n\n    // If user found the ball or game is over => reveal ball\n    if ((foundBall || gameOver) && ballPosition !== null) {\n      // The ball is at the same X as the cup with ball, y=180\n      const bx = cups[ballPosition].curX;\n      drawBall3D(ctx, bx, 180);\n    }\n  }\n  function drawCup3D(ctx, x, y, cupColor, disabled) {\n    ctx.save();\n\n    // Realistic shadow directly under the cup (small offset)\n    ctx.fillStyle = 'rgba(0,0,0,0.3)';\n    ctx.beginPath();\n    ctx.ellipse(x, y + 5, 30, 8, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Cup color gradient\n    let topColor = cupColor;\n    let bottomColor = cupColor;\n    if (disabled) {\n      topColor = '#ddd';\n      bottomColor = '#bbb';\n    } else {\n      if (cupColor === 'orange') {\n        topColor = '#FFA500';\n        bottomColor = '#FF8C00';\n      } else if (cupColor === 'red') {\n        topColor = '#ff6666';\n        bottomColor = '#ff0000';\n      } else if (cupColor === 'gold') {\n        topColor = '#FFD700';\n        bottomColor = '#FFC107';\n      }\n    }\n    const grad = ctx.createLinearGradient(x, y - 60, x, y);\n    grad.addColorStop(0, topColor);\n    grad.addColorStop(1, bottomColor);\n    ctx.fillStyle = grad;\n\n    // Body\n    ctx.beginPath();\n    ctx.moveTo(x - 20, y - 60);\n    ctx.lineTo(x - 30, y);\n    ctx.lineTo(x + 30, y);\n    ctx.lineTo(x + 20, y - 60);\n    ctx.closePath();\n    ctx.fill();\n\n    // Top ellipse\n    ctx.beginPath();\n    ctx.ellipse(x, y - 60, 20, 8, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Bottom ellipse (rim)\n    ctx.beginPath();\n    ctx.ellipse(x, y, 30, 10, 0, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.restore();\n  }\n  function drawBall3D(ctx, x, y) {\n    ctx.save();\n\n    // Shadow right under ball\n    ctx.fillStyle = 'rgba(0,0,0,0.2)';\n    ctx.beginPath();\n    ctx.ellipse(x, y + 15, 14, 5, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Yellow ball gradient\n    const grad = ctx.createRadialGradient(x - 5, y - 5, 4, x, y, 14);\n    grad.addColorStop(0, '#ffffaa'); // lighter\n    grad.addColorStop(1, 'yellow'); // deeper yellow\n\n    ctx.fillStyle = grad;\n    ctx.beginPath();\n    ctx.arc(x, y + 5, 14, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.restore();\n  }\n  function handleCanvasClick(e) {\n    if (!canvasRef.current) return;\n    // If you want to disable clicks during shuffle, uncomment:\n    // if (shuffling) return;\n\n    const rect = canvasRef.current.getBoundingClientRect();\n    const clickX = e.clientX - rect.left;\n    const clickY = e.clientY - rect.top;\n\n    // Approx bounding circles at (cups[i].curX, 180), radius ~ 40\n    cups.forEach((cup, index) => {\n      const dx = clickX - cup.curX;\n      const dy = clickY - 180;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist < 40) {\n        onCupClick(index);\n      }\n    });\n  }\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    width: width,\n    height: height,\n    onClick: handleCanvasClick,\n    style: {\n      border: '1px solid #ccc',\n      display: 'block',\n      margin: '0 auto'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 255,\n    columnNumber: 5\n  }, this);\n}\n_s(ShellGameCanvas, \"M0TOjwQik7zwy2jJ3ETRz6GtPmw=\");\n_c = ShellGameCanvas;\nexport default ShellGameCanvas;\nvar _c;\n$RefreshReg$(_c, \"ShellGameCanvas\");","map":{"version":3,"names":["React","useRef","useEffect","useState","jsxDEV","_jsxDEV","ShellGameCanvas","ballPosition","disabledCups","gameOver","foundBall","onCupClick","_s","canvasRef","width","height","cups","setCups","curX","targetX","color","shuffleTotal","shuffleStepsLeft","setShuffleStepsLeft","shuffling","setShuffling","canvas","current","ctx","getContext","bgImage","Image","src","animationFrameId","animate","updatePositions","drawScene","requestAnimationFrame","doShuffle","cancelAnimationFrame","oldPositions","map","c","positions","isSame","attemptCount","i","length","j","Math","floor","random","every","p","idx","prev","cup","prevCups","allArrived","newCups","speed","dx","abs","s","setTimeout","clearRect","complete","naturalWidth","drawImage","fillStyle","fillRect","forEach","isDisabled","drawCup3D","bx","drawBall3D","x","y","cupColor","disabled","save","beginPath","ellipse","PI","fill","topColor","bottomColor","grad","createLinearGradient","addColorStop","moveTo","lineTo","closePath","restore","createRadialGradient","arc","handleCanvasClick","e","rect","getBoundingClientRect","clickX","clientX","left","clickY","clientY","top","index","dy","dist","sqrt","ref","onClick","style","border","display","margin","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/rzeinalov/Developer/shell-game/client/src/ShellGameCanvas.js"],"sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\n\n/**\n * Props:\n *  - ballPosition: which cup (0..2) actually hides the ball\n *  - disabledCups: array of bools [cup0Disabled, cup1Disabled, cup2Disabled]\n *  - gameOver: bool\n *  - foundBall: bool (true if user guessed it)\n *  - onCupClick(index) => void\n */\nfunction ShellGameCanvas({\n  ballPosition,\n  disabledCups,\n  gameOver,\n  foundBall,\n  onCupClick\n}) {\n  const canvasRef = useRef(null);\n\n  const width = 600;\n  const height = 300;\n\n  // We'll track each cup's color and current/target X positions for animation.\n  // They all share the same Y = 180\n  // Cup #0 => orange, #1 => red, #2 => gold\n  const [cups, setCups] = useState([\n    { curX: 100, targetX: 100, color: 'orange' },\n    { curX: 300, targetX: 300, color: 'red' },\n    { curX: 500, targetX: 500, color: 'gold' }\n  ]);\n\n  // How many times we shuffle (swap) at the start\n  const shuffleTotal = 3;\n  // Track how many shuffle steps are left\n  const [shuffleStepsLeft, setShuffleStepsLeft] = useState(shuffleTotal);\n  // Are we currently shuffling?\n  const [shuffling, setShuffling] = useState(true);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n\n    // Load a background image if desired\n    const bgImage = new Image();\n    bgImage.src = '/background.jpg';\n\n    let animationFrameId;\n\n    function animate() {\n      updatePositions();\n      drawScene(ctx, bgImage);\n      animationFrameId = requestAnimationFrame(animate);\n    }\n    animate();\n\n    // Start the initial shuffle\n    doShuffle();\n\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n    };\n    // eslint-disable-next-line\n  }, []);\n\n  /**\n   * doShuffle():\n   * Called once to do a random shuffle. If we have multiple steps, once the cups\n   * arrive at their new positions, we call doShuffle() again, until shuffleStepsLeft=0.\n   * \n   * We ensure the new arrangement differs from the old arrangement so that cups actually move.\n   */\n  function doShuffle() {\n    if (shuffleStepsLeft <= 0) {\n      setShuffling(false);\n      return;\n    }\n\n    // Current arrangement\n    const oldPositions = cups.map(c => c.targetX);\n\n    // Generate a random permutation of the X positions [100, 300, 500]\n    let positions;\n    let isSame;\n    let attemptCount = 0;\n    do {\n      positions = [100, 300, 500];\n      for (let i = positions.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [positions[i], positions[j]] = [positions[j], positions[i]];\n      }\n      // Compare with old arrangement\n      isSame = positions.every((p, idx) => p === oldPositions[idx]);\n      attemptCount++;\n    } while (isSame && attemptCount < 10);\n\n    // Update each cup's targetX with the new (guaranteed different) permutation\n    setCups(prev => prev.map((cup, i) => ({\n      ...cup,\n      targetX: positions[i]\n    })));\n  }\n\n  // Move each cup from curX toward targetX each frame\n  function updatePositions() {\n    setCups(prevCups => {\n      let allArrived = true;\n      const newCups = prevCups.map(cup => {\n        const speed = 0.1; // fraction of distance to move each frame\n        const dx = cup.targetX - cup.curX;\n        if (Math.abs(dx) < 0.5) {\n          // Snap\n          return { ...cup, curX: cup.targetX };\n        } else {\n          allArrived = false;\n          return { ...cup, curX: cup.curX + dx * speed };\n        }\n      });\n\n      // If all cups arrived at their target, do next shuffle step\n      if (allArrived && shuffling && shuffleStepsLeft > 0) {\n        setShuffleStepsLeft(s => s - 1);\n        // Wait a moment, then do the next shuffle\n        setTimeout(() => {\n          doShuffle();\n        }, 300);\n      }\n\n      return newCups;\n    });\n  }\n\n  function drawScene(ctx, bgImage) {\n    ctx.clearRect(0, 0, width, height);\n\n    // Background\n    if (bgImage.complete && bgImage.naturalWidth > 0) {\n      ctx.drawImage(bgImage, 0, 0, width, height);\n    } else {\n      ctx.fillStyle = '#a5d8ff';\n      ctx.fillRect(0, 0, width, height);\n    }\n\n    // Draw cups\n    cups.forEach((cup, i) => {\n      const isDisabled = disabledCups[i];\n      drawCup3D(ctx, cup.curX, 180, cup.color, isDisabled);\n    });\n\n    // If user found the ball or game is over => reveal ball\n    if ((foundBall || gameOver) && ballPosition !== null) {\n      // The ball is at the same X as the cup with ball, y=180\n      const bx = cups[ballPosition].curX;\n      drawBall3D(ctx, bx, 180);\n    }\n  }\n\n  function drawCup3D(ctx, x, y, cupColor, disabled) {\n    ctx.save();\n\n    // Realistic shadow directly under the cup (small offset)\n    ctx.fillStyle = 'rgba(0,0,0,0.3)';\n    ctx.beginPath();\n    ctx.ellipse(x, y + 5, 30, 8, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Cup color gradient\n    let topColor = cupColor;\n    let bottomColor = cupColor;\n    if (disabled) {\n      topColor = '#ddd';\n      bottomColor = '#bbb';\n    } else {\n      if (cupColor === 'orange') {\n        topColor = '#FFA500'; \n        bottomColor = '#FF8C00';\n      } else if (cupColor === 'red') {\n        topColor = '#ff6666';\n        bottomColor = '#ff0000';\n      } else if (cupColor === 'gold') {\n        topColor = '#FFD700'; \n        bottomColor = '#FFC107';\n      }\n    }\n\n    const grad = ctx.createLinearGradient(x, y - 60, x, y);\n    grad.addColorStop(0, topColor);\n    grad.addColorStop(1, bottomColor);\n    ctx.fillStyle = grad;\n\n    // Body\n    ctx.beginPath();\n    ctx.moveTo(x - 20, y - 60);\n    ctx.lineTo(x - 30, y);\n    ctx.lineTo(x + 30, y);\n    ctx.lineTo(x + 20, y - 60);\n    ctx.closePath();\n    ctx.fill();\n\n    // Top ellipse\n    ctx.beginPath();\n    ctx.ellipse(x, y - 60, 20, 8, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Bottom ellipse (rim)\n    ctx.beginPath();\n    ctx.ellipse(x, y, 30, 10, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  function drawBall3D(ctx, x, y) {\n    ctx.save();\n\n    // Shadow right under ball\n    ctx.fillStyle = 'rgba(0,0,0,0.2)';\n    ctx.beginPath();\n    ctx.ellipse(x, y + 15, 14, 5, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Yellow ball gradient\n    const grad = ctx.createRadialGradient(x - 5, y - 5, 4, x, y, 14);\n    grad.addColorStop(0, '#ffffaa'); // lighter\n    grad.addColorStop(1, 'yellow');  // deeper yellow\n\n    ctx.fillStyle = grad;\n    ctx.beginPath();\n    ctx.arc(x, y + 5, 14, 0, 2 * Math.PI);\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  function handleCanvasClick(e) {\n    if (!canvasRef.current) return;\n    // If you want to disable clicks during shuffle, uncomment:\n    // if (shuffling) return;\n\n    const rect = canvasRef.current.getBoundingClientRect();\n    const clickX = e.clientX - rect.left;\n    const clickY = e.clientY - rect.top;\n\n    // Approx bounding circles at (cups[i].curX, 180), radius ~ 40\n    cups.forEach((cup, index) => {\n      const dx = clickX - cup.curX;\n      const dy = clickY - 180;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist < 40) {\n        onCupClick(index);\n      }\n    });\n  }\n\n  return (\n    <canvas\n      ref={canvasRef}\n      width={width}\n      height={height}\n      onClick={handleCanvasClick}\n      style={{ border: '1px solid #ccc', display: 'block', margin: '0 auto' }}\n    />\n  );\n}\n\nexport default ShellGameCanvas;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}