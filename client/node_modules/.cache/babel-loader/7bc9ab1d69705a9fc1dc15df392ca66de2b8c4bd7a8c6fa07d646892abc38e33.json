{"ast":null,"code":"var _jsxFileName = \"/Users/rzeinalov/Developer/shell-game/client/src/ShellGameCanvas.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState } from 'react';\n\n/**\n * Props:\n *  - ballPosition: which cup (0..2) actually hides the ball\n *  - disabledCups: array of bools [cup0Disabled, cup1Disabled, cup2Disabled]\n *  - gameOver: bool\n *  - foundBall: bool (true if user guessed it)\n *  - onCupClick(index) => void\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction ShellGameCanvas({\n  ballPosition,\n  disabledCups,\n  gameOver,\n  foundBall,\n  onCupClick\n}) {\n  _s();\n  const canvasRef = useRef(null);\n  const width = 600;\n  const height = 300;\n\n  // We'll track each cup's color and current/target X positions for animation.\n  // They all share the same Y = 180\n  // Cup #0 => orange, #1 => red, #2 => gold\n  const [cups, setCups] = useState([{\n    curX: 100,\n    targetX: 100,\n    color: 'orange'\n  }, {\n    curX: 300,\n    targetX: 300,\n    color: 'red'\n  }, {\n    curX: 500,\n    targetX: 500,\n    color: 'gold'\n  }]);\n\n  // How many times we shuffle (swap) at the start\n  const shuffleTotal = 3;\n  // Track how many shuffle steps are left\n  const [shuffleStepsLeft, setShuffleStepsLeft] = useState(shuffleTotal);\n  // Are we currently shuffling?\n  const [shuffling, setShuffling] = useState(true);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n\n    // Load a background image if desired\n    const bgImage = new Image();\n    bgImage.src = '/background.jpg';\n    let animationFrameId;\n    function animate() {\n      updatePositions();\n      drawScene(ctx, bgImage);\n      animationFrameId = requestAnimationFrame(animate);\n    }\n    animate();\n\n    // Start the initial shuffle\n    doShuffle();\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n    };\n    // eslint-disable-next-line\n  }, []);\n\n  // Called once to do a random shuffle. If we have multiple steps, once the cups\n  // arrive at their new positions, we call doShuffle() again, until shuffleStepsLeft=0.\n  function doShuffle() {\n    // If no steps left, end shuffling\n    if (shuffleStepsLeft <= 0) {\n      setShuffling(false);\n      return;\n    }\n\n    // Generate a random permutation of the X positions [100, 300, 500]\n    const positions = [100, 300, 500];\n    for (let i = positions.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [positions[i], positions[j]] = [positions[j], positions[i]];\n    }\n\n    // Update each cup's targetX with the new permutation\n    setCups(prev => prev.map((cup, i) => ({\n      ...cup,\n      targetX: positions[i]\n    })));\n\n    // Once they arrive, we'll decrement shuffleStepsLeft and doShuffle again\n  }\n\n  // Move each cup from curX toward targetX each frame\n  function updatePositions() {\n    setCups(prevCups => {\n      let allArrived = true;\n      const newCups = prevCups.map(cup => {\n        const speed = 0.1; // fraction of distance to move each frame\n        const dx = cup.targetX - cup.curX;\n        if (Math.abs(dx) < 0.5) {\n          // Snap\n          return {\n            ...cup,\n            curX: cup.targetX\n          };\n        } else {\n          allArrived = false;\n          return {\n            ...cup,\n            curX: cup.curX + dx * speed\n          };\n        }\n      });\n\n      // If all cups arrived at their target, do next shuffle\n      if (allArrived && shuffling && shuffleStepsLeft > 0) {\n        setShuffleStepsLeft(s => s - 1);\n        setTimeout(() => {\n          doShuffle();\n        }, 300);\n      }\n      return newCups;\n    });\n  }\n  function drawScene(ctx, bgImage) {\n    ctx.clearRect(0, 0, width, height);\n\n    // Background\n    if (bgImage.complete && bgImage.naturalWidth > 0) {\n      ctx.drawImage(bgImage, 0, 0, width, height);\n    } else {\n      ctx.fillStyle = '#a5d8ff';\n      ctx.fillRect(0, 0, width, height);\n    }\n\n    // Draw cups\n    cups.forEach((cup, i) => {\n      const isDisabled = disabledCups[i];\n      drawCup3D(ctx, cup.curX, 180, cup.color, isDisabled);\n    });\n\n    // If user found the ball or game is over => reveal ball\n    if ((foundBall || gameOver) && ballPosition !== null) {\n      // The ball is at the same X as the cup with ball, y=180\n      const bx = cups[ballPosition].curX;\n      drawBall3D(ctx, bx, 180);\n    }\n  }\n  function drawCup3D(ctx, x, y, cupColor, disabled) {\n    ctx.save();\n\n    // Realistic shadow directly under the cup\n    ctx.fillStyle = 'rgba(0,0,0,0.3)';\n    ctx.beginPath();\n    // We'll make the shadow a small ellipse just under y\n    ctx.ellipse(x, y + 5, 30, 8, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Cup color gradient. We'll define a top and bottom color for each base color\n    let topColor = cupColor;\n    let bottomColor = cupColor;\n    // Adjust for disabled or highlight\n    if (disabled) {\n      topColor = '#ddd';\n      bottomColor = '#bbb';\n    } else {\n      if (cupColor === 'orange') {\n        topColor = '#FFA500'; // a bright orange\n        bottomColor = '#FF8C00';\n      } else if (cupColor === 'red') {\n        topColor = '#ff6666';\n        bottomColor = '#ff0000';\n      } else if (cupColor === 'gold') {\n        topColor = '#FFD700';\n        bottomColor = '#FFC107';\n      }\n    }\n    const grad = ctx.createLinearGradient(x, y - 60, x, y);\n    grad.addColorStop(0, topColor);\n    grad.addColorStop(1, bottomColor);\n    ctx.fillStyle = grad;\n\n    // Body\n    ctx.beginPath();\n    ctx.moveTo(x - 20, y - 60);\n    ctx.lineTo(x - 30, y);\n    ctx.lineTo(x + 30, y);\n    ctx.lineTo(x + 20, y - 60);\n    ctx.closePath();\n    ctx.fill();\n\n    // Top ellipse\n    ctx.beginPath();\n    ctx.ellipse(x, y - 60, 20, 8, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Bottom ellipse (rim)\n    ctx.beginPath();\n    ctx.ellipse(x, y, 30, 10, 0, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.restore();\n  }\n  function drawBall3D(ctx, x, y) {\n    ctx.save();\n\n    // Shadow right under ball\n    ctx.fillStyle = 'rgba(0,0,0,0.2)';\n    ctx.beginPath();\n    ctx.ellipse(x, y + 15, 14, 5, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Yellow ball gradient\n    const grad = ctx.createRadialGradient(x - 5, y - 5, 4, x, y, 14);\n    grad.addColorStop(0, '#ffffaa');\n    grad.addColorStop(1, 'yellow');\n    ctx.fillStyle = grad;\n    ctx.beginPath();\n    ctx.arc(x, y + 5, 14, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.restore();\n  }\n  function handleCanvasClick(e) {\n    if (!canvasRef.current) return;\n    // If we want to prevent clicking while shuffling:\n    // if (shuffling) return;\n\n    const rect = canvasRef.current.getBoundingClientRect();\n    const clickX = e.clientX - rect.left;\n    const clickY = e.clientY - rect.top;\n\n    // Approx bounding circles at (cups[i].curX, 180), radius ~ 40\n    cups.forEach((cup, index) => {\n      const dx = clickX - cup.curX;\n      const dy = clickY - 180;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist < 40) {\n        onCupClick(index);\n      }\n    });\n  }\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    width: width,\n    height: height,\n    onClick: handleCanvasClick,\n    style: {\n      border: '1px solid #ccc',\n      display: 'block',\n      margin: '0 auto'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 243,\n    columnNumber: 5\n  }, this);\n}\n_s(ShellGameCanvas, \"M0TOjwQik7zwy2jJ3ETRz6GtPmw=\");\n_c = ShellGameCanvas;\nexport default ShellGameCanvas;\nvar _c;\n$RefreshReg$(_c, \"ShellGameCanvas\");","map":{"version":3,"names":["React","useRef","useEffect","useState","jsxDEV","_jsxDEV","ShellGameCanvas","ballPosition","disabledCups","gameOver","foundBall","onCupClick","_s","canvasRef","width","height","cups","setCups","curX","targetX","color","shuffleTotal","shuffleStepsLeft","setShuffleStepsLeft","shuffling","setShuffling","canvas","current","ctx","getContext","bgImage","Image","src","animationFrameId","animate","updatePositions","drawScene","requestAnimationFrame","doShuffle","cancelAnimationFrame","positions","i","length","j","Math","floor","random","prev","map","cup","prevCups","allArrived","newCups","speed","dx","abs","s","setTimeout","clearRect","complete","naturalWidth","drawImage","fillStyle","fillRect","forEach","isDisabled","drawCup3D","bx","drawBall3D","x","y","cupColor","disabled","save","beginPath","ellipse","PI","fill","topColor","bottomColor","grad","createLinearGradient","addColorStop","moveTo","lineTo","closePath","restore","createRadialGradient","arc","handleCanvasClick","e","rect","getBoundingClientRect","clickX","clientX","left","clickY","clientY","top","index","dy","dist","sqrt","ref","onClick","style","border","display","margin","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/rzeinalov/Developer/shell-game/client/src/ShellGameCanvas.js"],"sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\n\n/**\n * Props:\n *  - ballPosition: which cup (0..2) actually hides the ball\n *  - disabledCups: array of bools [cup0Disabled, cup1Disabled, cup2Disabled]\n *  - gameOver: bool\n *  - foundBall: bool (true if user guessed it)\n *  - onCupClick(index) => void\n */\nfunction ShellGameCanvas({\n  ballPosition,\n  disabledCups,\n  gameOver,\n  foundBall,\n  onCupClick\n}) {\n  const canvasRef = useRef(null);\n\n  const width = 600;\n  const height = 300;\n\n  // We'll track each cup's color and current/target X positions for animation.\n  // They all share the same Y = 180\n  // Cup #0 => orange, #1 => red, #2 => gold\n  const [cups, setCups] = useState([\n    { curX: 100, targetX: 100, color: 'orange' },\n    { curX: 300, targetX: 300, color: 'red' },\n    { curX: 500, targetX: 500, color: 'gold' }\n  ]);\n\n  // How many times we shuffle (swap) at the start\n  const shuffleTotal = 3;\n  // Track how many shuffle steps are left\n  const [shuffleStepsLeft, setShuffleStepsLeft] = useState(shuffleTotal);\n  // Are we currently shuffling?\n  const [shuffling, setShuffling] = useState(true);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n\n    // Load a background image if desired\n    const bgImage = new Image();\n    bgImage.src = '/background.jpg';\n\n    let animationFrameId;\n\n    function animate() {\n      updatePositions();\n      drawScene(ctx, bgImage);\n      animationFrameId = requestAnimationFrame(animate);\n    }\n    animate();\n\n    // Start the initial shuffle\n    doShuffle();\n\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n    };\n    // eslint-disable-next-line\n  }, []);\n\n  // Called once to do a random shuffle. If we have multiple steps, once the cups\n  // arrive at their new positions, we call doShuffle() again, until shuffleStepsLeft=0.\n  function doShuffle() {\n    // If no steps left, end shuffling\n    if (shuffleStepsLeft <= 0) {\n      setShuffling(false);\n      return;\n    }\n\n    // Generate a random permutation of the X positions [100, 300, 500]\n    const positions = [100, 300, 500];\n    for (let i = positions.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [positions[i], positions[j]] = [positions[j], positions[i]];\n    }\n\n    // Update each cup's targetX with the new permutation\n    setCups(prev => prev.map((cup, i) => ({\n      ...cup,\n      targetX: positions[i]\n    })));\n\n    // Once they arrive, we'll decrement shuffleStepsLeft and doShuffle again\n  }\n\n  // Move each cup from curX toward targetX each frame\n  function updatePositions() {\n    setCups(prevCups => {\n      let allArrived = true;\n      const newCups = prevCups.map(cup => {\n        const speed = 0.1; // fraction of distance to move each frame\n        const dx = cup.targetX - cup.curX;\n        if (Math.abs(dx) < 0.5) {\n          // Snap\n          return { ...cup, curX: cup.targetX };\n        } else {\n          allArrived = false;\n          return { ...cup, curX: cup.curX + dx * speed };\n        }\n      });\n\n      // If all cups arrived at their target, do next shuffle\n      if (allArrived && shuffling && shuffleStepsLeft > 0) {\n        setShuffleStepsLeft(s => s - 1);\n        setTimeout(() => {\n          doShuffle();\n        }, 300); \n      }\n\n      return newCups;\n    });\n  }\n\n  function drawScene(ctx, bgImage) {\n    ctx.clearRect(0, 0, width, height);\n\n    // Background\n    if (bgImage.complete && bgImage.naturalWidth > 0) {\n      ctx.drawImage(bgImage, 0, 0, width, height);\n    } else {\n      ctx.fillStyle = '#a5d8ff';\n      ctx.fillRect(0, 0, width, height);\n    }\n\n    // Draw cups\n    cups.forEach((cup, i) => {\n      const isDisabled = disabledCups[i];\n      drawCup3D(ctx, cup.curX, 180, cup.color, isDisabled);\n    });\n\n    // If user found the ball or game is over => reveal ball\n    if ((foundBall || gameOver) && ballPosition !== null) {\n      // The ball is at the same X as the cup with ball, y=180\n      const bx = cups[ballPosition].curX;\n      drawBall3D(ctx, bx, 180);\n    }\n  }\n\n  function drawCup3D(ctx, x, y, cupColor, disabled) {\n    ctx.save();\n\n    // Realistic shadow directly under the cup\n    ctx.fillStyle = 'rgba(0,0,0,0.3)';\n    ctx.beginPath();\n    // We'll make the shadow a small ellipse just under y\n    ctx.ellipse(x, y + 5, 30, 8, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Cup color gradient. We'll define a top and bottom color for each base color\n    let topColor = cupColor;\n    let bottomColor = cupColor;\n    // Adjust for disabled or highlight\n    if (disabled) {\n      topColor = '#ddd';\n      bottomColor = '#bbb';\n    } else {\n      if (cupColor === 'orange') {\n        topColor = '#FFA500'; // a bright orange\n        bottomColor = '#FF8C00'; \n      } else if (cupColor === 'red') {\n        topColor = '#ff6666'; \n        bottomColor = '#ff0000'; \n      } else if (cupColor === 'gold') {\n        topColor = '#FFD700'; \n        bottomColor = '#FFC107'; \n      }\n    }\n\n    const grad = ctx.createLinearGradient(x, y - 60, x, y);\n    grad.addColorStop(0, topColor);\n    grad.addColorStop(1, bottomColor);\n    ctx.fillStyle = grad;\n\n    // Body\n    ctx.beginPath();\n    ctx.moveTo(x - 20, y - 60);\n    ctx.lineTo(x - 30, y);\n    ctx.lineTo(x + 30, y);\n    ctx.lineTo(x + 20, y - 60);\n    ctx.closePath();\n    ctx.fill();\n\n    // Top ellipse\n    ctx.beginPath();\n    ctx.ellipse(x, y - 60, 20, 8, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Bottom ellipse (rim)\n    ctx.beginPath();\n    ctx.ellipse(x, y, 30, 10, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  function drawBall3D(ctx, x, y) {\n    ctx.save();\n\n    // Shadow right under ball\n    ctx.fillStyle = 'rgba(0,0,0,0.2)';\n    ctx.beginPath();\n    ctx.ellipse(x, y + 15, 14, 5, 0, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Yellow ball gradient\n    const grad = ctx.createRadialGradient(x - 5, y - 5, 4, x, y, 14);\n    grad.addColorStop(0, '#ffffaa');\n    grad.addColorStop(1, 'yellow');\n\n    ctx.fillStyle = grad;\n    ctx.beginPath();\n    ctx.arc(x, y + 5, 14, 0, 2 * Math.PI);\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  function handleCanvasClick(e) {\n    if (!canvasRef.current) return;\n    // If we want to prevent clicking while shuffling:\n    // if (shuffling) return;\n\n    const rect = canvasRef.current.getBoundingClientRect();\n    const clickX = e.clientX - rect.left;\n    const clickY = e.clientY - rect.top;\n\n    // Approx bounding circles at (cups[i].curX, 180), radius ~ 40\n    cups.forEach((cup, index) => {\n      const dx = clickX - cup.curX;\n      const dy = clickY - 180;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist < 40) {\n        onCupClick(index);\n      }\n    });\n  }\n\n  return (\n    <canvas\n      ref={canvasRef}\n      width={width}\n      height={height}\n      onClick={handleCanvasClick}\n      style={{ border: '1px solid #ccc', display: 'block', margin: '0 auto' }}\n    />\n  );\n}\n\nexport default ShellGameCanvas;\n"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,MAAM,EAAEC,SAAS,EAAEC,QAAQ,QAAQ,OAAO;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA,SAAAC,MAAA,IAAAC,OAAA;AAQA,SAASC,eAAeA,CAAC;EACvBC,YAAY;EACZC,YAAY;EACZC,QAAQ;EACRC,SAAS;EACTC;AACF,CAAC,EAAE;EAAAC,EAAA;EACD,MAAMC,SAAS,GAAGZ,MAAM,CAAC,IAAI,CAAC;EAE9B,MAAMa,KAAK,GAAG,GAAG;EACjB,MAAMC,MAAM,GAAG,GAAG;;EAElB;EACA;EACA;EACA,MAAM,CAACC,IAAI,EAAEC,OAAO,CAAC,GAAGd,QAAQ,CAAC,CAC/B;IAAEe,IAAI,EAAE,GAAG;IAAEC,OAAO,EAAE,GAAG;IAAEC,KAAK,EAAE;EAAS,CAAC,EAC5C;IAAEF,IAAI,EAAE,GAAG;IAAEC,OAAO,EAAE,GAAG;IAAEC,KAAK,EAAE;EAAM,CAAC,EACzC;IAAEF,IAAI,EAAE,GAAG;IAAEC,OAAO,EAAE,GAAG;IAAEC,KAAK,EAAE;EAAO,CAAC,CAC3C,CAAC;;EAEF;EACA,MAAMC,YAAY,GAAG,CAAC;EACtB;EACA,MAAM,CAACC,gBAAgB,EAAEC,mBAAmB,CAAC,GAAGpB,QAAQ,CAACkB,YAAY,CAAC;EACtE;EACA,MAAM,CAACG,SAAS,EAAEC,YAAY,CAAC,GAAGtB,QAAQ,CAAC,IAAI,CAAC;EAEhDD,SAAS,CAAC,MAAM;IACd,MAAMwB,MAAM,GAAGb,SAAS,CAACc,OAAO;IAChC,MAAMC,GAAG,GAAGF,MAAM,CAACG,UAAU,CAAC,IAAI,CAAC;;IAEnC;IACA,MAAMC,OAAO,GAAG,IAAIC,KAAK,CAAC,CAAC;IAC3BD,OAAO,CAACE,GAAG,GAAG,iBAAiB;IAE/B,IAAIC,gBAAgB;IAEpB,SAASC,OAAOA,CAAA,EAAG;MACjBC,eAAe,CAAC,CAAC;MACjBC,SAAS,CAACR,GAAG,EAAEE,OAAO,CAAC;MACvBG,gBAAgB,GAAGI,qBAAqB,CAACH,OAAO,CAAC;IACnD;IACAA,OAAO,CAAC,CAAC;;IAET;IACAI,SAAS,CAAC,CAAC;IAEX,OAAO,MAAM;MACXC,oBAAoB,CAACN,gBAAgB,CAAC;IACxC,CAAC;IACD;EACF,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA;EACA,SAASK,SAASA,CAAA,EAAG;IACnB;IACA,IAAIhB,gBAAgB,IAAI,CAAC,EAAE;MACzBG,YAAY,CAAC,KAAK,CAAC;MACnB;IACF;;IAEA;IACA,MAAMe,SAAS,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IACjC,KAAK,IAAIC,CAAC,GAAGD,SAAS,CAACE,MAAM,GAAG,CAAC,EAAED,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC7C,MAAME,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAIL,CAAC,GAAG,CAAC,CAAC,CAAC;MAC7C,CAACD,SAAS,CAACC,CAAC,CAAC,EAAED,SAAS,CAACG,CAAC,CAAC,CAAC,GAAG,CAACH,SAAS,CAACG,CAAC,CAAC,EAAEH,SAAS,CAACC,CAAC,CAAC,CAAC;IAC7D;;IAEA;IACAxB,OAAO,CAAC8B,IAAI,IAAIA,IAAI,CAACC,GAAG,CAAC,CAACC,GAAG,EAAER,CAAC,MAAM;MACpC,GAAGQ,GAAG;MACN9B,OAAO,EAAEqB,SAAS,CAACC,CAAC;IACtB,CAAC,CAAC,CAAC,CAAC;;IAEJ;EACF;;EAEA;EACA,SAASN,eAAeA,CAAA,EAAG;IACzBlB,OAAO,CAACiC,QAAQ,IAAI;MAClB,IAAIC,UAAU,GAAG,IAAI;MACrB,MAAMC,OAAO,GAAGF,QAAQ,CAACF,GAAG,CAACC,GAAG,IAAI;QAClC,MAAMI,KAAK,GAAG,GAAG,CAAC,CAAC;QACnB,MAAMC,EAAE,GAAGL,GAAG,CAAC9B,OAAO,GAAG8B,GAAG,CAAC/B,IAAI;QACjC,IAAI0B,IAAI,CAACW,GAAG,CAACD,EAAE,CAAC,GAAG,GAAG,EAAE;UACtB;UACA,OAAO;YAAE,GAAGL,GAAG;YAAE/B,IAAI,EAAE+B,GAAG,CAAC9B;UAAQ,CAAC;QACtC,CAAC,MAAM;UACLgC,UAAU,GAAG,KAAK;UAClB,OAAO;YAAE,GAAGF,GAAG;YAAE/B,IAAI,EAAE+B,GAAG,CAAC/B,IAAI,GAAGoC,EAAE,GAAGD;UAAM,CAAC;QAChD;MACF,CAAC,CAAC;;MAEF;MACA,IAAIF,UAAU,IAAI3B,SAAS,IAAIF,gBAAgB,GAAG,CAAC,EAAE;QACnDC,mBAAmB,CAACiC,CAAC,IAAIA,CAAC,GAAG,CAAC,CAAC;QAC/BC,UAAU,CAAC,MAAM;UACfnB,SAAS,CAAC,CAAC;QACb,CAAC,EAAE,GAAG,CAAC;MACT;MAEA,OAAOc,OAAO;IAChB,CAAC,CAAC;EACJ;EAEA,SAAShB,SAASA,CAACR,GAAG,EAAEE,OAAO,EAAE;IAC/BF,GAAG,CAAC8B,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE5C,KAAK,EAAEC,MAAM,CAAC;;IAElC;IACA,IAAIe,OAAO,CAAC6B,QAAQ,IAAI7B,OAAO,CAAC8B,YAAY,GAAG,CAAC,EAAE;MAChDhC,GAAG,CAACiC,SAAS,CAAC/B,OAAO,EAAE,CAAC,EAAE,CAAC,EAAEhB,KAAK,EAAEC,MAAM,CAAC;IAC7C,CAAC,MAAM;MACLa,GAAG,CAACkC,SAAS,GAAG,SAAS;MACzBlC,GAAG,CAACmC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEjD,KAAK,EAAEC,MAAM,CAAC;IACnC;;IAEA;IACAC,IAAI,CAACgD,OAAO,CAAC,CAACf,GAAG,EAAER,CAAC,KAAK;MACvB,MAAMwB,UAAU,GAAGzD,YAAY,CAACiC,CAAC,CAAC;MAClCyB,SAAS,CAACtC,GAAG,EAAEqB,GAAG,CAAC/B,IAAI,EAAE,GAAG,EAAE+B,GAAG,CAAC7B,KAAK,EAAE6C,UAAU,CAAC;IACtD,CAAC,CAAC;;IAEF;IACA,IAAI,CAACvD,SAAS,IAAID,QAAQ,KAAKF,YAAY,KAAK,IAAI,EAAE;MACpD;MACA,MAAM4D,EAAE,GAAGnD,IAAI,CAACT,YAAY,CAAC,CAACW,IAAI;MAClCkD,UAAU,CAACxC,GAAG,EAAEuC,EAAE,EAAE,GAAG,CAAC;IAC1B;EACF;EAEA,SAASD,SAASA,CAACtC,GAAG,EAAEyC,CAAC,EAAEC,CAAC,EAAEC,QAAQ,EAAEC,QAAQ,EAAE;IAChD5C,GAAG,CAAC6C,IAAI,CAAC,CAAC;;IAEV;IACA7C,GAAG,CAACkC,SAAS,GAAG,iBAAiB;IACjClC,GAAG,CAAC8C,SAAS,CAAC,CAAC;IACf;IACA9C,GAAG,CAAC+C,OAAO,CAACN,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG1B,IAAI,CAACgC,EAAE,CAAC;IAC/ChD,GAAG,CAACiD,IAAI,CAAC,CAAC;;IAEV;IACA,IAAIC,QAAQ,GAAGP,QAAQ;IACvB,IAAIQ,WAAW,GAAGR,QAAQ;IAC1B;IACA,IAAIC,QAAQ,EAAE;MACZM,QAAQ,GAAG,MAAM;MACjBC,WAAW,GAAG,MAAM;IACtB,CAAC,MAAM;MACL,IAAIR,QAAQ,KAAK,QAAQ,EAAE;QACzBO,QAAQ,GAAG,SAAS,CAAC,CAAC;QACtBC,WAAW,GAAG,SAAS;MACzB,CAAC,MAAM,IAAIR,QAAQ,KAAK,KAAK,EAAE;QAC7BO,QAAQ,GAAG,SAAS;QACpBC,WAAW,GAAG,SAAS;MACzB,CAAC,MAAM,IAAIR,QAAQ,KAAK,MAAM,EAAE;QAC9BO,QAAQ,GAAG,SAAS;QACpBC,WAAW,GAAG,SAAS;MACzB;IACF;IAEA,MAAMC,IAAI,GAAGpD,GAAG,CAACqD,oBAAoB,CAACZ,CAAC,EAAEC,CAAC,GAAG,EAAE,EAAED,CAAC,EAAEC,CAAC,CAAC;IACtDU,IAAI,CAACE,YAAY,CAAC,CAAC,EAAEJ,QAAQ,CAAC;IAC9BE,IAAI,CAACE,YAAY,CAAC,CAAC,EAAEH,WAAW,CAAC;IACjCnD,GAAG,CAACkC,SAAS,GAAGkB,IAAI;;IAEpB;IACApD,GAAG,CAAC8C,SAAS,CAAC,CAAC;IACf9C,GAAG,CAACuD,MAAM,CAACd,CAAC,GAAG,EAAE,EAAEC,CAAC,GAAG,EAAE,CAAC;IAC1B1C,GAAG,CAACwD,MAAM,CAACf,CAAC,GAAG,EAAE,EAAEC,CAAC,CAAC;IACrB1C,GAAG,CAACwD,MAAM,CAACf,CAAC,GAAG,EAAE,EAAEC,CAAC,CAAC;IACrB1C,GAAG,CAACwD,MAAM,CAACf,CAAC,GAAG,EAAE,EAAEC,CAAC,GAAG,EAAE,CAAC;IAC1B1C,GAAG,CAACyD,SAAS,CAAC,CAAC;IACfzD,GAAG,CAACiD,IAAI,CAAC,CAAC;;IAEV;IACAjD,GAAG,CAAC8C,SAAS,CAAC,CAAC;IACf9C,GAAG,CAAC+C,OAAO,CAACN,CAAC,EAAEC,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG1B,IAAI,CAACgC,EAAE,CAAC;IAChDhD,GAAG,CAACiD,IAAI,CAAC,CAAC;;IAEV;IACAjD,GAAG,CAAC8C,SAAS,CAAC,CAAC;IACf9C,GAAG,CAAC+C,OAAO,CAACN,CAAC,EAAEC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG1B,IAAI,CAACgC,EAAE,CAAC;IAC5ChD,GAAG,CAACiD,IAAI,CAAC,CAAC;IAEVjD,GAAG,CAAC0D,OAAO,CAAC,CAAC;EACf;EAEA,SAASlB,UAAUA,CAACxC,GAAG,EAAEyC,CAAC,EAAEC,CAAC,EAAE;IAC7B1C,GAAG,CAAC6C,IAAI,CAAC,CAAC;;IAEV;IACA7C,GAAG,CAACkC,SAAS,GAAG,iBAAiB;IACjClC,GAAG,CAAC8C,SAAS,CAAC,CAAC;IACf9C,GAAG,CAAC+C,OAAO,CAACN,CAAC,EAAEC,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG1B,IAAI,CAACgC,EAAE,CAAC;IAChDhD,GAAG,CAACiD,IAAI,CAAC,CAAC;;IAEV;IACA,MAAMG,IAAI,GAAGpD,GAAG,CAAC2D,oBAAoB,CAAClB,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAE,CAAC,EAAED,CAAC,EAAEC,CAAC,EAAE,EAAE,CAAC;IAChEU,IAAI,CAACE,YAAY,CAAC,CAAC,EAAE,SAAS,CAAC;IAC/BF,IAAI,CAACE,YAAY,CAAC,CAAC,EAAE,QAAQ,CAAC;IAE9BtD,GAAG,CAACkC,SAAS,GAAGkB,IAAI;IACpBpD,GAAG,CAAC8C,SAAS,CAAC,CAAC;IACf9C,GAAG,CAAC4D,GAAG,CAACnB,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,GAAG1B,IAAI,CAACgC,EAAE,CAAC;IACrChD,GAAG,CAACiD,IAAI,CAAC,CAAC;IAEVjD,GAAG,CAAC0D,OAAO,CAAC,CAAC;EACf;EAEA,SAASG,iBAAiBA,CAACC,CAAC,EAAE;IAC5B,IAAI,CAAC7E,SAAS,CAACc,OAAO,EAAE;IACxB;IACA;;IAEA,MAAMgE,IAAI,GAAG9E,SAAS,CAACc,OAAO,CAACiE,qBAAqB,CAAC,CAAC;IACtD,MAAMC,MAAM,GAAGH,CAAC,CAACI,OAAO,GAAGH,IAAI,CAACI,IAAI;IACpC,MAAMC,MAAM,GAAGN,CAAC,CAACO,OAAO,GAAGN,IAAI,CAACO,GAAG;;IAEnC;IACAlF,IAAI,CAACgD,OAAO,CAAC,CAACf,GAAG,EAAEkD,KAAK,KAAK;MAC3B,MAAM7C,EAAE,GAAGuC,MAAM,GAAG5C,GAAG,CAAC/B,IAAI;MAC5B,MAAMkF,EAAE,GAAGJ,MAAM,GAAG,GAAG;MACvB,MAAMK,IAAI,GAAGzD,IAAI,CAAC0D,IAAI,CAAChD,EAAE,GAAGA,EAAE,GAAG8C,EAAE,GAAGA,EAAE,CAAC;MACzC,IAAIC,IAAI,GAAG,EAAE,EAAE;QACb1F,UAAU,CAACwF,KAAK,CAAC;MACnB;IACF,CAAC,CAAC;EACJ;EAEA,oBACE9F,OAAA;IACEkG,GAAG,EAAE1F,SAAU;IACfC,KAAK,EAAEA,KAAM;IACbC,MAAM,EAAEA,MAAO;IACfyF,OAAO,EAAEf,iBAAkB;IAC3BgB,KAAK,EAAE;MAAEC,MAAM,EAAE,gBAAgB;MAAEC,OAAO,EAAE,OAAO;MAAEC,MAAM,EAAE;IAAS;EAAE;IAAAC,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACzE,CAAC;AAEN;AAACpG,EAAA,CAhPQN,eAAe;AAAA2G,EAAA,GAAf3G,eAAe;AAkPxB,eAAeA,eAAe;AAAC,IAAA2G,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}